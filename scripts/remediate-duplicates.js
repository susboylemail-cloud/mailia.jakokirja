#!/usr/bin/env node
/*
Remediation helper for duplicate addresses across circuits.

Inputs:
- duplicates-report.json (generated by scripts/find-duplicates.js)
- duplicates-whitelist.json (optional): list of accepted shared buildings/units

Outputs:
- remediation-report.json: actionable list of high-risk duplicates (not whitelisted)
- remediation-report.csv: flat CSV for manual review in spreadsheet

Whitelist format (duplicates-whitelist.json):
{
  "buildings": [
    // You can use simple strings or objects with circuits restriction
    "keskuskatu 10",
    { "key": "kuppilantie 16", "circuits": ["KP25", "KP51"], "reason": "shared coverage intentional" }
  ],
  "units": [
    // Unit key format comes from find-duplicates: "<street number>|<porras>|<asunto>"
    { "key": "keskuskatu 10|a|12", "circuits": ["KP18"] }
  ]
}
*/
const fs = require('fs');
const path = require('path');
const cp = require('child_process');

const ROOT = process.cwd();
const REPORT_JSON = path.join(ROOT, 'duplicates-report.json');
const WHITELIST_JSON = path.join(ROOT, 'duplicates-whitelist.json');
const OUT_JSON = path.join(ROOT, 'remediation-report.json');
const OUT_CSV = path.join(ROOT, 'remediation-report.csv');
const SUGGESTIONS_JSON = path.join(ROOT, 'duplicates-whitelist.suggestions.json');

// CLI flags
const args = process.argv.slice(2);
const AUTO_SUGGEST = args.includes('--write-suggestions');
const AUTO_CLASSIFY = true; // enable heuristic tagging by default

function ensureDuplicateReport(){
  if (fs.existsSync(REPORT_JSON)) return;
  console.log('duplicates-report.json not found. Generating via scripts/find-duplicates.js ...');
  const res = cp.spawnSync(process.execPath, ['scripts/find-duplicates.js'], { cwd: ROOT, stdio: 'inherit' });
  if (res.status !== 0) {
    throw new Error('Failed to generate duplicates-report.json');
  }
}

function loadJson(file, fallback){
  try {
    if (!fs.existsSync(file)) return fallback;
    return JSON.parse(fs.readFileSync(file, 'utf8'));
  } catch (e) {
    console.warn(`Failed to parse ${file}:`, e.message);
    return fallback;
  }
}

function writeDefaultWhitelist(){
  if (fs.existsSync(WHITELIST_JSON)) return;
  const tpl = {
    buildings: [],
    units: []
  };
  fs.writeFileSync(WHITELIST_JSON, JSON.stringify(tpl, null, 2), 'utf8');
  console.log('Created empty duplicates-whitelist.json. Fill it to accept intentional overlaps.');
}

function normalizeWhitelistEntries(arr){
  // Normalize to objects: { key: string, circuits: string[]|undefined }
  return (arr || []).map(e => {
    if (typeof e === 'string') return { key: e, circuits: undefined };
    if (e && typeof e === 'object') return { key: String(e.key || ''), circuits: Array.isArray(e.circuits) ? e.circuits.map(String) : undefined, reason: e.reason };
    return null;
  }).filter(Boolean);
}

function isWhitelisted(level, key, circuits, whitelist){
  const entries = normalizeWhitelistEntries(whitelist[level] || []);
  for (const w of entries){
    if (!w.key) continue;
    if (w.key.toLowerCase() !== key.toLowerCase()) continue;
    if (!w.circuits || w.circuits.includes('*')) return true;
    // All involved circuits must be covered by whitelist circuits
    const cset = new Set(circuits);
    const wset = new Set(w.circuits.map(c => c.toUpperCase()))
    let allCovered = true;
    for (const c of cset){ if (!wset.has(c.toUpperCase())) { allCovered = false; break; } }
    if (allCovered) return true;
  }
  return false;
}

function classifyDuplicate(entry){
  const tags = [];
  if (/\d+[A-Za-z]$/.test(entry.key)) tags.push('letter-suffix');
  const base = entry.key.replace(/\s+([0-9]+)[A-Za-z]$/,(m,num)=>` ${num}`);
  if (base !== entry.key && /\d+$/.test(base)) tags.push('numeric-base');
  if ((entry.circuits||[]).length > 1) {
    const nums = (entry.circuits||[]).map(c => c.replace(/[^0-9]/g,'')).filter(Boolean);
    if (nums.length && nums.every(n => n === nums[0])) tags.push('same-circuit-number');
  }
  return tags;
}

function buildRemediation(){
  ensureDuplicateReport();
  writeDefaultWhitelist();
  const report = loadJson(REPORT_JSON, null);
  if (!report) throw new Error('duplicates-report.json missing or invalid');
  const whitelist = loadJson(WHITELIST_JSON, { buildings: [], units: [] });

  const highRiskBuildings = [];
  const highRiskUnits = [];

  const suggestionWhitelist = { buildings: [], units: [] };

  for (const d of report.globalBuildingDuplicates || []){
    if ((d.circuits || []).length <= 1) continue;
    if (isWhitelisted('buildings', d.key, d.circuits, whitelist)) continue;
    if (AUTO_CLASSIFY) d.tags = classifyDuplicate(d);
    // Suggest whitelist if letters differ OR circuits share same number
    if (d.tags && (d.tags.includes('letter-suffix') || d.tags.includes('same-circuit-number'))) {
      suggestionWhitelist.buildings.push({ key: d.key, circuits: d.circuits, reason: d.tags.join(',') });
    }
    highRiskBuildings.push(d);
  }
  for (const d of report.globalUnitDuplicates || []){
    if ((d.circuits || []).length <= 1) continue;
    if (isWhitelisted('units', d.key, d.circuits, whitelist)) continue;
    if (AUTO_CLASSIFY) d.tags = classifyDuplicate(d);
    if (d.tags && (d.tags.includes('letter-suffix') || d.tags.includes('same-circuit-number'))) {
      suggestionWhitelist.units.push({ key: d.key, circuits: d.circuits, reason: d.tags.join(',') });
    }
    highRiskUnits.push(d);
  }

  // Per-circuit rollup with suggested actions
  const perCircuit = {};
  function addCircuitEntry(level, d){
    const circuits = d.circuits || [];
    for (const c of circuits){
      perCircuit[c] = perCircuit[c] || { buildings: [], units: [] };
      const entry = {
        key: d.key,
        level,
        totalOccurrences: d.totalOccurrences,
        otherCircuits: circuits.filter(x => x !== c),
        suggestion: 'review-overlap'
      };
      if (level === 'building') perCircuit[c].buildings.push(entry);
      else perCircuit[c].units.push(entry);
    }
  }
  highRiskBuildings.forEach(d => addCircuitEntry('building', d));
  highRiskUnits.forEach(d => addCircuitEntry('unit', d));

  const output = {
    generatedAt: new Date().toISOString(),
    totals: {
      highRiskBuildings: highRiskBuildings.length,
      highRiskUnits: highRiskUnits.length
    },
    highRiskBuildings,
    highRiskUnits,
    perCircuit
  };
  fs.writeFileSync(OUT_JSON, JSON.stringify(output, null, 2), 'utf8');
  if (AUTO_SUGGEST) {
    fs.writeFileSync(SUGGESTIONS_JSON, JSON.stringify(suggestionWhitelist, null, 2), 'utf8');
    console.log(`Suggestion whitelist written to ${SUGGESTIONS_JSON}`);
  }

  // Flat CSV
  const csv = [];
  csv.push(['level', 'key', 'total_occurrences', 'circuits'].join(','));
  for (const d of highRiskBuildings){
    csv.push(['building', escapeCsv(d.key), d.totalOccurrences, escapeCsv((d.circuits || []).join('|')), escapeCsv((d.tags||[]).join('|'))].join(','));
  }
  for (const d of highRiskUnits){
    csv.push(['unit', escapeCsv(d.key), d.totalOccurrences, escapeCsv((d.circuits || []).join('|')), escapeCsv((d.tags||[]).join('|'))].join(','));
  }
  fs.writeFileSync(OUT_CSV, csv.join('\n'), 'utf8');

  console.log(`High-risk buildings: ${highRiskBuildings.length}`);
  console.log(`High-risk units: ${highRiskUnits.length}`);
  console.log(`Wrote ${OUT_JSON} and ${OUT_CSV}`);
}

function escapeCsv(v){
  const s = String(v ?? '');
  if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
  return s;
}

try {
  buildRemediation();
} catch (e) {
  console.error('Remediation failed:', e.message || e);
  process.exit(1);
}
